#AUTOGENERATED! DO NOT EDIT! File to edit: dev/01_curveCreation.ipynb (unless otherwise specified).

__all__ = ['getArcEndposition', 'getArcCurvatureAndLength', 'getArcCurvatureAndLength2Point', 'endTurn2LaneStreet']

#Cell
from math import floor, pi
import numpy as np
from .utils import giveHeading, distance,schnittpunkt,getXYPositionFromLineLength,getPositiveHeading,getDeltaHdg

#Cell
def getArcEndposition(curvature,length,xstart,ystart,hdg_start):
    deltaHdg = curvature*length
    hdg_end = deltaHdg + hdg_start
    if abs(curvature) > 0.0:
        radius = length/deltaHdg
        #get Midpoint of Arc
        #turn 90 degree in curvature, walk to the radius to M, then turn back
        #and substract deltaHeading and walk radius back
        if curvature < 0.0:
            x_M = np.cos(hdg_start+np.pi/2.0)*radius+xstart
            y_M = np.sin(hdg_start+np.pi/2.0)*radius + ystart
            x_end = np.cos(hdg_start-np.pi/2.0+deltaHdg)*radius+x_M
            y_end = np.sin(hdg_start-np.pi/2.0+deltaHdg)*radius+y_M
        else:
            x_M = np.cos(hdg_start+np.pi/2.0)*radius+xstart
            y_M = np.sin(hdg_start+np.pi/2.0)*radius + ystart
            x_end = np.cos(hdg_start-np.pi/2.0+deltaHdg)*radius+x_M
            y_end = np.sin(hdg_start-np.pi/2.0+deltaHdg)*radius+y_M
    else:
        x_end = np.cos(hdg_start)*length +xstart
        y_end = np.sin(hdg_start)*length + ystart
    return x_end, y_end, getPositiveHeading(hdg_end)

#Cell
def getArcCurvatureAndLength(xstart,ystart,x_end,y_end, x_curveMid, y_curveMid, maxerror = 0.8, minradius = 0.5, iterations = 10):
    #print("Calculating Curve from {0},{1}  over {2},{3} to {4},{5}".format(xstart,ystart,x_curveMid, y_curveMid,x_end,y_end))
    hdg_start = giveHeading(xstart,ystart,x_curveMid, y_curveMid)
    hdg_mid2end = giveHeading(x_curveMid, y_curveMid, x_end,y_end)
    assert hdg_start != hdg_mid2end, "The directions have to be different!"
    deltaHdg = getDeltaHdg(hdg_start,hdg_mid2end)
    #print("deltaHdg = {}".format(deltaHdg))
    winkelHalbHdg = deltaHdg/2.0 + hdg_start
    maxDist = distance(x_curveMid,y_curveMid,xstart,ystart) if distance(x_curveMid,y_curveMid,xstart,ystart) <= \
                distance(x_curveMid,y_curveMid,x_end,y_end) else distance(x_curveMid,y_curveMid,x_end,y_end)
    if abs(deltaHdg) < 0.0001:
        return xstart,ystart,x_end,y_end,0.0,distance(xstart,ystart,x_end,y_end)
    hdg_90_a = hdg_start-np.pi/2.0
    hdg_90_b = hdg_mid2end - np.pi/2.0

    #dist = < maxDist

    #x1 = x_curveMid + dist*np.cos(hdg_start-np.pi)
    #y1 = y_curveMid + dist*np.sin(hdg_start-np.pi)
    #x2 = x_curveMid + dist*np.cos(hdg_mid2end)
    #y2 = y_curveMid + dist*np.sin(hdg_mid2end)
    #r1 = (-y2 + y1)/((np.sin(hdg_90_a)  + np.sin(hdg_90_b) * (x1 + np.cos(hdg_90_a))/(x2 + np.cos(hdg_90_b)) ))
    #x_m = x1 + np.cos(hdg_90_a) * r1
    #y_m = y1 - np.sin(hdg_90_a) * r1
    #error = ((x_m-x_curveMid)**2 + (y_m-y_curveMid)**2)**0.5  - r1
    # get dist from error...

    dist = maxDist
    bestDist = dist
    x1 = x_curveMid + dist*np.cos(hdg_start-np.pi)
    y1 = y_curveMid + dist*np.sin(hdg_start-np.pi)
    x2 = x_curveMid + dist*np.cos(hdg_mid2end)
    y2 = y_curveMid + dist*np.sin(hdg_mid2end)
    x_m,y_m,r1,r2 = schnittpunkt(x1,y1,hdg_90_a,x2,y2,hdg_90_b)
    error = distance(x_m,y_m,x_curveMid,y_curveMid) - abs(r1)
    if error < maxerror:
        #print("Error: {0}".format(error))
        pass
    else:
        bestDist = minradius
        notWorkingDist = dist
        for i in range(iterations):
            dist = (bestDist + notWorkingDist)/2.0
            x1 = x_curveMid + dist*np.cos(hdg_start-np.pi)
            y1 = y_curveMid + dist*np.sin(hdg_start-np.pi)
            x2 = x_curveMid + dist*np.cos(hdg_mid2end)
            y2 = y_curveMid + dist*np.sin(hdg_mid2end)
            x_m,y_m,r1,r2 = schnittpunkt(x1,y1,hdg_90_a,x2,y2,hdg_90_b)
            error = distance(x_m,y_m,x_curveMid,y_curveMid) - abs(r1)
            if error < maxerror:
                bestDist = dist
            else:
                notWorkingDist = dist
            #print("BestDistance:{0}  Error: {1}".format(bestDist,error))
    x1 = x_curveMid + bestDist*np.cos(hdg_start-np.pi)
    y1 = y_curveMid + bestDist*np.sin(hdg_start-np.pi)
    x2 = x_curveMid + bestDist*np.cos(hdg_mid2end)
    y2 = y_curveMid + bestDist*np.sin(hdg_mid2end)
    x_s,y_s,r1,r2 = schnittpunkt(x1,y1,hdg_90_a,x2,y2,hdg_90_b)
    length = abs(r1)*abs(deltaHdg)  #2pi r für vollen kreisbogen
    curvature = -deltaHdg / length
    return x1,y1,x2,y2,curvature,length

#Cell
def getArcCurvatureAndLength2Point(xstart,ystart,x_end,y_end, hdg_start, hdg_end):
    if abs(hdg_start - hdg_end) < 0.0001:
        if abs(giveHeading(xstart,ystart,x_end,y_end) - hdg_start) < 0.0001:
            return {"ArcStartCoordinatesXY":[xstart, ystart],"ArcCurvatureLength":[0.0,distance(xstart,ystart,x_end,y_end)],"StartlineLength":0.0,"EndlineLength":0.0,"EndlineStartCoordinatesXY":[x_end, y_end]}
        else:
            #parallele Linien! todo mach nen vernünftigen wert draus
            return {"ArcStartCoordinatesXY":[xstart, ystart],"ArcCurvatureLength":[0.0,distance(xstart,ystart,x_end,y_end)],"StartlineLength":0.0,"EndlineLength":0.0,"EndlineStartCoordinatesXY":[x_end, y_end]}
    hdg_end = hdg_end-np.pi
    # get a synthetic midpoint
    x_s,y_s,r1,r2 = schnittpunkt(xstart,ystart,hdg_start,x_end,y_end,hdg_end)
    #print("schnittpunkt: r1:{0}  r2:{1}".format(r1,r2))
    # 3 cases: either this is the curve-point (r1 and r2 positive) or it is the centerpoint of to diverging lines (r1 and r2 negative)
    # or this is the centerpoint of a new imaginary line (one of both negative, one positive)
    if r1 > 0.0 and r2 > 0.0:
        x1,y1,x2,y2,curvature,length = getArcCurvatureAndLength(xstart,ystart,x_end,y_end, x_s, y_s, maxerror = 999999999.8, minradius = 0.5, iterations = 10)
        return {"ArcStartCoordinatesXY":[x1, y1],"ArcCurvatureLength":[curvature,length],"StartlineLength":distance(xstart,ystart,x1,y1),"EndlineLength":distance(x_end,y_end,x2,y2),"EndlineStartCoordinatesXY":[x2,y2]}
    if r1 < 0.0 and r2 < 0.0:
        # ensure r1 and r2 are the same length (maximum)
        maximumLinelength = max(abs(r1),abs(r2))
        startlineLength = maximumLinelength - abs(r1)
        endlineLength = maximumLinelength - abs(r2)

    if min(r1,r2)< 0.0 and max(r1,r2) > 0.0:
        #the maximum will have to run forward to the intersection and then again forward with the length of the abs(minimum)
        startlineLength = r1 + abs(r2) if r1 == max(r1,r2) else 0.0
        endlineLength = r2 + abs(r1) if r2 == max(r1,r2) else 0.0
    x_startL, y_startL = getXYPositionFromLineLength(xstart, ystart, hdg_start, startlineLength)
    x_endL, y_endL = getXYPositionFromLineLength(x_end, y_end, hdg_end, endlineLength)
    #get opposite curve - error should be high enough to let the curve start from the beginning points
    _,_,_,_,curvature,length = getArcCurvatureAndLength(x_startL,y_startL,x_endL,y_endL, x_s, y_s, maxerror = 999.8, minradius = 0.5, iterations = 10)
    #get the opposide part of the circle
    deltaHdg = 2*np.pi - abs(length*curvature)
    length = abs(deltaHdg/curvature)

    return {"ArcStartCoordinatesXY":[x_startL, y_startL],"ArcCurvatureLength":[curvature,length],"StartlineLength":startlineLength,"EndlineLength":endlineLength,"EndlineStartCoordinatesXY":[x_endL, y_endL]}

#Cell
def endTurn2LaneStreet(x_start,y_start, hdg_start, preTurnLength = 3.0):
    #create a hard 45° turn in 1 meter
    x_1, y_1, hdg_1 = getArcEndposition(-np.pi/(4.0*preTurnLength),preTurnLength,x_start,y_start,hdg_start)
    x_2, y_2, hdg_2 = getArcEndposition(np.pi/(4.0*preTurnLength),preTurnLength,x_start,y_start,hdg_start)
    hdg_2 += np.pi
    hdg_2 = hdg_2 % (2.*np.pi)
    #get the appropriate curvature
    returnDict = getArcCurvatureAndLength2Point(x_1,y_1,x_2,y_2, hdg_1, hdg_2-np.pi)
    returnDict["StartPointXYHdg"] = [x_start,y_start,hdg_start]
    returnDict["BeginningArcCurvatureLength"] = [-np.pi/(4.0*preTurnLength),preTurnLength]
    returnDict["BeginningArcEndXYHdg"] = [x_1, y_1,hdg_1]
    returnDict["EndLineHdg"] = hdg_2
    returnDict["EndArcBeginningXYHdgCurvatureLength"] = [x_2, y_2,hdg_2,-np.pi/(4.0*preTurnLength),preTurnLength]
    return returnDict